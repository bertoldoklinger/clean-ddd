- nao levar o dry muito a risca
- sempre separar casos de uso parecidos e entidades, pois quando precisarmos extender com regras de negocio especificas, será mais facil
- design de software tem que traduzir a linguagem ubiqua(do mundo real) em código
- repositorios cuidam das camadas de persistencia de dados
- slug é uma representação de um texto, porem sem acento, sem caracteres especiais, bom para indexação das buscas, não utilizar id da do texto
- value objects sao classes dentro de classes, atributos de uma classe que possuem comportamento , que são imutaveis
- string.normalize('NFKD') => retira qualquer tipo de acentuação de uma string e devolve sem acentuacao nenhuma
- protected pode ser acessado pela classe e por todas as classes filhas(extends)
- criamos uma entity base para inicializar as props e id das entidades do projeto, assim deixando codigo mais limpo(limpando os construtores) e retirando a inicializacao de props na classe
- criamos o value object do unique entity id para separarmos a geraçao de um uuid(node:crypto) da nossa entidade base e podemos assim trocar para outras como da lib uuid
- getters e setters são porta de entrada e saida da nossa entidade, fazendo com que a gente proteja algumas entidades, não dando acesso a modificacao a alguns atributos, e forma de fazer validação ou manipulaçao desses atributos
- so criar setter conforme precisar
- fetch para listar varias e get para listar apenas uma
- quando trabalhamos com listagem, paginação é obrigatoria até nos use-cases
- como ordenar os mais recentes(feito no repository) => const questions = this.items.sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime(),)
- para retornar entidades paginadas no repository, devemos pegar o parametro page(pode pegar page e perPage tbm) e passar para .slice((page - 1) * 20(ou perPage), page * 20(ou perPage))
- polimorfismo é uma entidade que pode se comportar como duas ou mais formas diferentes, pode ter mais formas dentro da mesma entidade => ex : um Comment pode ser um AnswerComment ou um QuestionComment(com herança) ou um Comment
- classe abstrata é uma classe que não pode ser instanciada sozinha, ela sempre vai precisar ser extendida por outra classe(herança) para ela ser instanciada
- throw funciona diferente do return, throw dispara um erro e não termina o fluxo da funcao, já o return sim e se a função que estiver chamando nao tiver um try catch, vai bater no error handler global e retornando um internal server error 500, erro ruim
- não é interessante usar throw para identificar nossos erros, usar throw impossibilita retornar respostas diferentes para erros diferentes
- O **Aggregate** é quando temos uma entidade que depende de outra entidade para ela existir
  - Exemplo
    - Order => OrderItem[]
    - Order => Shipping
- **Aggregate** é um conjunto de entidades que são manipuladas ao mesmo tempo, e elas, juntas, compõem algo maior, que é o Aggregate
- No DDD, o aggregate pode fazer coisas que entidades simples não podem fazer
- **WatchedLists** são listas observadas, que funcionam como um array, onde tu consegue fazer buscas nessa lista, ou adicionar, ou remover
- O **AggregateRoot** sempre é a entidade principal dentro de um agregado de entidades
- Toda AggregateRoot é uma entidade